# compute_cache.py
"""
Compute Cache Module (LRU + TTL + Disk Persistence)
计算缓存模块（内存 LRU + TTL + 磁盘持久化）
Author//作者: QilongJiang
Date//日期: 2026-02-11
"""
from typing import Optional, Any
from collections import OrderedDict
import threading
import time
import pickle
from ..file_parser.workspace_utils import get_workspace_dir


class ComputeCache:
    """
    ComputeCache: in-memory LRU + TTL cache with optional workspace persistence
    计算缓存：内存 LRU + TTL，并可选落盘到 workspace

    ============================================================================
    1) Role / 定位
    ----------------------------------------------------------------------------
    This cache is designed to hold "heavy compute artifacts" (e.g., Geom after
    canonicalization/sorting) and reuse them across pipeline runs within a process,
    while optionally persisting to disk for cross-run reuse.

    该缓存用于存放“计算代价高、体积大”的产物（例如排序完成的 Geom），
    实现：
      - 进程内复用：LRU + TTL（快速）
      - 跨运行复用：workspace 目录 pickle（可选）

    ============================================================================
    2) Cache policy / 缓存策略
    ----------------------------------------------------------------------------
    (A) In-memory:
        - LRU eviction: keep most recently used items (OrderedDict move_to_end)
        - TTL expiration: entry invalid if now - entry["time"] > ttl

    (B) Disk (workspace persistence):
        - If memory miss/expired, try to load from disk:
            {workspace}/{key}/{key}_sorted_geom.pkl
        - When set(..., save_to_disk=True), dump to the same path.

    ============================================================================
    3) Concurrency / 并发
    ----------------------------------------------------------------------------
    - Thread-safe for in-memory operations via a single lock.
    - Disk IO is performed outside the lock to avoid blocking other threads.

    注意：磁盘 IO 在锁外执行，避免长时间持锁导致并发退化。

    ============================================================================
    4) Integrity & warnings / 完整性与风险提示（重要）
    ----------------------------------------------------------------------------
    - Pickle is not stable across code versions / class layout changes.
      If Geom/Object/Triangle definition changes, old pickle may fail to load or
      load into incompatible state.

    - Pickle is not safe for untrusted inputs. The workspace directory must be
      considered trusted (generated by this project only).

    - Key design MUST incorporate configuration that affects the artifact.
      For Geom, key should include (model_hash + acc + order params), otherwise
      reuse can be incorrect even if loading succeeds.

    ============================================================================
    5) Failure behavior / 失败策略
    ----------------------------------------------------------------------------
    - Any exception during disk load/save is caught and printed.
      Cache degrades gracefully to "no cache" rather than failing the pipeline.
    """

    def __init__(self, max_size: int = 10, ttl: int = 3600):
        """
        Initialize cache
        初始化缓存

        Parameters / 参数
        -----------------
        max_size:
            Maximum number of items in memory (LRU capacity).
            内存缓存最大条目数（超过则 LRU 淘汰）。

        ttl:
            Time-to-live in seconds for in-memory entries.
            内存条目的存活时间（秒），超过则视为过期并删除。

        Notes / 注意
        ------------
        - TTL only applies to in-memory entries. Disk persistence does not expire
          automatically in this implementation.
        - 当前实现只对内存条目做 TTL；磁盘上的 pickle 不会自动过期（由 key/version 管控）。
        """
        self._max_size = max_size
        self._ttl = ttl

        # OrderedDict implements LRU by moving accessed keys to the end.
        # OrderedDict 通过 move_to_end 实现 LRU：最近使用的放末尾，淘汰最前面的
        self._cache: OrderedDict = OrderedDict()

        # Coarse-grained lock for thread safety on memory operations.
        # 线程安全：对内存缓存的操作使用同一个锁
        self._lock = threading.Lock()

    def get(self, key: str) -> Optional[Any]:
        """
        Retrieve cached value by key (memory first, then disk fallback)
        读取缓存值（优先内存，其次磁盘回退）

        Lookup order / 查找顺序
        -----------------------
        1) In-memory:
            - hit + not expired => return value and update LRU order
            - hit + expired     => delete and proceed to disk
            - miss              => proceed to disk

        2) Disk fallback:
            - try to load pickle from workspace:
                {ws}/{key}/{key}_sorted_geom.pkl
            - if success: insert into memory (save_to_disk=False) and return

        Failure modes / 失败模式
        ------------------------
        - On any disk IO/unpickle error: print warning and return None.
        - This cache is best-effort and must not break the main pipeline.
        """
        # -----------------------------
        # (1) In-memory fast path
        # -----------------------------
        with self._lock:
            if key in self._cache:
                entry = self._cache[key]

                # TTL check: valid if current time - entry_time <= ttl
                # TTL 校验：未超过 ttl 则有效
                if time.time() - entry["time"] <= self._ttl:
                    # Update LRU order: mark as recently used
                    # 更新 LRU：把该 key 移动到末尾
                    self._cache.move_to_end(key)
                    return entry["value"]

                # Expired: remove from memory and fall back to disk
                # 过期：从内存删除，继续尝试磁盘加载
                del self._cache[key]

        # -----------------------------
        # (2) Disk fallback (lock-free)
        # -----------------------------
        # Disk IO is outside lock to reduce contention.
        # 磁盘 IO 放在锁外，避免阻塞其他线程访问内存 cache
        try:
            ws_dir = get_workspace_dir()
            file_path = ws_dir / key / f"{key}_sorted_geom.pkl"

            # Only attempt load if file exists
            # 文件存在才尝试读取
            if file_path.exists():
                with open(file_path, "rb") as f:
                    value = pickle.load(f)

                # Reinsert into memory without re-saving to disk.
                # 读到后回填内存，但不重复落盘
                self.set(key, value, save_to_disk=False)
                return value

        except Exception as e:
            # Best-effort: do not raise, degrade to cache miss.
            # 兜底策略：不抛异常，退化为 miss
            print(f"[Cache] Error loading {key}: {e}")

        return None

    def set(self, key: str, value: Any, save_to_disk: bool = True) -> None:
        """
        Insert/refresh cached value (memory + optional disk persistence)
        写入/刷新缓存（写内存 + 可选落盘）

        Memory behavior / 内存行为
        -------------------------
        - Always writes to in-memory cache with timestamp.
        - Updates LRU order (move_to_end).
        - If capacity exceeded, evicts LRU (oldest) entry.

        Disk behavior / 磁盘行为
        ------------------------
        - If save_to_disk=True:
            pickle.dump(value) to:
              {ws}/{key}/{key}_sorted_geom.pkl

        Notes / 注意
        ------------
        - Disk IO occurs outside the lock to reduce contention.
        - Pickle writes are best-effort; failure will be printed but not raised.
        """
        # -----------------------------
        # (1) Write into memory (locked)
        # -----------------------------
        with self._lock:
            # Store value and write-time
            # 存储 value 与写入时间戳
            self._cache[key] = {"value": value, "time": time.time()}

            # Mark as most recently used
            # 标记为最近使用
            self._cache.move_to_end(key)

            # Enforce capacity by evicting least recently used
            # 超过容量则淘汰最久未使用的条目（OrderedDict 头部）
            if len(self._cache) > self._max_size:
                self._cache.popitem(last=False)

        # -----------------------------
        # (2) Optional disk persistence
        # -----------------------------
        if save_to_disk:
            try:
                ws_dir = get_workspace_dir()
                save_dir = ws_dir / key

                # Ensure directory exists
                # 确保存储目录存在
                save_dir.mkdir(parents=True, exist_ok=True)

                file_path = save_dir / f"{key}_sorted_geom.pkl"

                # Persist with pickle (best-effort)
                # 使用 pickle 落盘（尽力而为）
                with open(file_path, "wb") as f:
                    pickle.dump(value, f)

            except Exception as e:
                print(f"[Cache] Error saving {key}: {e}")

    def clear(self) -> None:
        """
        Clear in-memory cache only
        清空内存缓存（不删除磁盘文件）

        Notes / 注意
        ------------
        - This does not touch workspace pickle files.
        - 若要清理磁盘缓存，应由外部删除 workspace/{key}/ 目录或提供专门清理函数。
        """
        with self._lock:
            self._cache.clear()
